#!/usr/bin/env ruby
require 'bundler/setup'

require 'terminal-table'
require 'thor'

require_relative 'engine.rb'

def challenges
  Dir.entries("challenges").reject { |e| e[0] == '.' }
end

def parse_leaderboard(challenge)
  path = "challenges/#{challenge}/leaderboard.txt"
  FileUtils.touch(path)
  lines = File.read(path).split("\n")
  leaderboard = {}
  lines.each do |line|
    parts = line.split(" ")
    leaderboard[parts[0]] = {
      differences: parts[1].to_i,
      cycles: parts[2].to_i,
    }
  end
  leaderboard
end

def save_leaderboard(challenge, leaderboard)
  path = "challenges/#{challenge}/leaderboard.txt"
  data = leaderboard.entries.sort_by do |key, value|
    "#{value[:differences]} #{value[:cycles]}"
  end.map do |key, value|
    "#{key} #{value[:differences]} #{value[:cycles]}"
  end.join("\n")
  File.write(path, data)
end

def update_leaderboard(challenge, program, differences, cycles)
  leaderboard = parse_leaderboard(challenge)
  leaderboard[program] = {differences: differences, cycles: cycles}
  save_leaderboard(challenge, leaderboard)
end

def print_leaderboard(challenge, you=nil)
  leaderboard = parse_leaderboard(challenge)
  rows = leaderboard.entries.sort_by do |key, value|
    "#{value[:differences]} #{value[:cycles]}"
  end.map do |key, value|
    if key == you
      key = "* " + key
    else
      key = "  " + key
    end
    [key, value[:differences], value[:cycles]]
  end
  table = Terminal::Table.new(
    headings: ["Solution", "Errors", "Cycles"],
    rows: rows,
  )
  puts "LEADERBOARD"
  puts table
end

class Challenge < Thor
  desc "list", "list names of all challenges"
  def list
    puts challenges
  end

  desc "describe CHALLENGE", "Print of details for CHALLENGE"
  def describe(challenge)
    target = File.read("challenges/#{challenge}/target.txt")
    puts "Target:"
    puts target
  end

  desc "create CHALLENGE", "Make a new challenge"
  def create(challenge)
    if File.directory?("challenges/#{challenge}")
      puts "A challenge with that name already exists."
      return
    end
    FileUtils.mkdir("challenges/#{challenge}")
    target_path = "challenges/#{challenge}/target.txt"
    FileUtils.cp('fixtures/sample.txt', target_path)
    puts "Fill in #{target_path}"
  end

  desc "attempt CHALLENGE PROGRAM", "Run PROGRAM on CHALLENGE and measure record results"
  def attempt(challenge, program)
    unless challenges.include?(challenge)
      raise "no exiting challenge named #{challenge}"
    end

    FileUtils.mkdir_p("challenges/#{challenge}/#{program}")
    program_path = "challenges/#{challenge}/#{program}/#{program}.cell"
    FileUtils.touch(program_path)
    program_bytes = File.read(program_path)
    if program_bytes.strip.length == 0
      puts "Write your program in #{program_path}"
      return
    end
    zygote = cell_from_file(program_path)

    target = target_from_file("challenges/#{challenge}/target.txt")

    log_path = "challenges/#{challenge}/#{program}/log.txt"
    world = nil
    cycles = nil
    File.open(log_path, 'w') do |log|
      world, cycles = simulate(zygote, target, log)
    end

    differences = count_differences(target, world.grid)
    if differences == 0
      puts "SUCCESS! (in #{cycles} cycles)"
    else
      puts "Result does not match (after #{cycles} cycles)"
      puts "#{differences} differences."
    end

    update_leaderboard(challenge, program, differences, cycles)

    puts "target:"
    print_target(target)
    puts "actual:"
    print_grid(world.grid, $stdout)
    puts "Logs in #{log_path}\n\n"
    print_leaderboard(challenge, program)
  end
end
 
class CLI < Thor
  register(Challenge, 'challenge', 'challenge <command>', 'Challenges')
end
 
CLI.start(ARGV)